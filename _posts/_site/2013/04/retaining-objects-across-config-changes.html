<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="google-site-verification" content="VqGny1x9EAeoXjY8v2hWFZGBUZFNQnavIOXVkY50mdk" />
    <meta name="msvalidate.01" content="AFECEF07C08280E3BFA946DDCE26B76C" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@alexjlockwood" />
    <meta name="twitter:creator" content="@alexjlockwood" />
    <meta name="twitter:domain" content="" />
    
    <!-- Don't include normal description meta tag for now. Only include twitter:description since it is explicitly required. -->
    <meta name="twitter:description" content="Android Design Patterns is a website for developers who wish to better understand the Android application framework. The tutorials here emphasize proper code design and project maintainability." />
    
    <meta property="og:locale" content="en_US" />
    <meta property="og:title" content="Handling Configuration Changes with Fragments" />
    
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2013-04-29T00:00:00-04:00" />
    <meta property="article:modified_time" content="2014-01-14T00:00:00-05:00" />
    
    <meta property="og:url" content="/2013/04/retaining-objects-across-config-changes.html" />
    <meta property="og:site_name" content="Android Design Patterns" />
    
    <meta property="og:image" content="/assets/images/posts/2013/04/29/worker-fragments-screenshot.png" />
    
    <meta property="og:image" content="/assets/images/favicon.jpg" />
    <title>Handling Configuration Changes with Fragments | Android Design Patterns</title>
    <link rel="canonical" href="/2013/04/retaining-objects-across-config-changes.html" />
    <link rel="icon" href="/assets/images/favicon.jpg" type="image/x-icon">
    <link href="/feed.atom" rel="alternate" title="Android Design Patterns - Feed" type="application/atom+xml" />
    <link rel="stylesheet" type="text/css" href="/css/all.css" />

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
  </head>

  <body>
    <div id="header">
      <div class="container">
        <h3 id="blog-header"><a href="/">Android Design Patterns</a></h3>
        <nav class="pull-right">
          <a href="/archives/">Archives</a>
          <a href="/about/">About</a>
        </nav>
      </div>
    </div>

    <div id="social" class="container">
      <a href="https://plus.google.com/100751609891157863386?rel=author" class="googleplus"><i class="icon-gplus"></i></a>
      <a href="https://twitter.com/alexjlockwood" class="twitter"><i class="icon-twitter"></i></a>
      <a href="https://github.com/alexjlockwood" class="github"><i class="icon-github-circled"></i></a>
      <a href="/feed.atom" class="rss"><i class="icon-rss"></i></a>
    </div>

    <div class="main container">
      <div id="content">
	<div class="blog-index">
          <div itemscope itemtype="http://schema.org/BlogPosting" class="post">
  <header><h1 itemprop="name">Handling Configuration Changes with Fragments</h1></header>

  <div class="side">
    <div class="date-posted" >
      Posted <span itemprop="datePublished" content="2013-04-29T00:00:00-04:00" class="date">Apr 29, 2013</span>
      <div class="author">by <a href="https://google.com/+AlexLockwood"><span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Alex Lockwood</span></span></a></div>
    </div>

    <div class="share-buttons">
      <div class="g-plusone" data-size="medium"></div>
      <div class="tweet"><a href="https://twitter.com/share" class="twitter-share-button" data-via="alexjlockwood" data-lang="en">Tweet</a></div>
      <div class="fb-like" data-href="/2013/04/retaining-objects-across-config-changes.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
    </div>
  </div>

  <div class="body">
    <div itemprop="articleBody">
      <p>This post addresses a common question that is frequently asked on <a href="http://stackoverflow.com/q/3821423/844882">StackOverflow</a>:</p>

<blockquote>
<p>What is the best way to retain active objects&mdash;such as
running <code>Thread</code>s, <code>Socket</code>s, and <code>AsyncTask</code>s&mdash;across
device configuration changes?</p>
</blockquote>

<p>To answer this question, we will first discuss some of the common
difficulties developers face when using long-running background tasks
in conjunction with the Activity lifecycle. Then, we will describe
the flaws of two common approaches to solving the problem. Finally,
we will conclude with sample code illustrating the recommended
solution, which uses retained Fragments to achieve our goal.</p>

<!--more-->

<h3>Configuration Changes &amp; Background Tasks</h3>

<p>One problem with configuration changes and the destroy-and-create cycle
that Activitys go through as a result stems from the fact that these events
are unpredictable and may occur at any time. Concurrent background tasks
only add to this problem. Assume, for example, that an Activity starts
an <code>AsyncTask</code> and soon after the user rotates the screen, causing the
Activity to be destroyed and recreated. When the <code>AsyncTask</code> eventually
finishes its work, it will incorrectly report its results back to the
old Activity instance, completely unaware that a new Activity has been
created. As if this wasn&#39;t already an issue, the new Activity instance
might waste valuable resources by firing up the background work <em>again</em>,
unaware that the old <code>AsyncTask</code> is still running. For these reasons,
it is vital that we correctly and efficiently retain active objects
across Activity instances when configuration changes occur.</p>

<h3>Bad Practice: Retain the Activity</h3>

<p>Perhaps the hackiest and most widely abused workaround is to disable
the default destroy-and-recreate behavior by setting the <code>android:configChanges</code>
attribute in your Android manifest. The apparent simplicity of this
approach makes it extremely attractive to developers;
<a href="http://stackoverflow.com/a/5336057/844882">Google engineers</a>,
however, discourage its use. The primary concern is that it requires you
to handle device configuration changes manually in code. Handling
configuration changes requires you to take many additional steps to
ensure that each and every string, layout, drawable, dimension, etc.
remains in sync with the device&#39;s current configuration, and if you
aren&#39;t careful, your application can easily have a whole series of
resource-specific bugs as a result.</p>

<p>Another reason why Google discourages its use is because many
developers incorrectly assume that setting <code>android:configChanges=&quot;orientation&quot;</code>
(for example) will magically protect their application from
unpredictable scenarios in which the underlying Activity will be
destroyed and recreated. <em>This is not the case.</em> Configuration
changes can occur for a number of reasons&mdash;not just screen
orientation changes. Inserting your device into a display dock,
changing the default language, and modifying the device&#39;s default
font scaling factor are just three examples of events that can
trigger a device configuration change, all of which signal the
system to destroy and recreate all currently running Activitys
the next time they are resumed. As a result, setting the
<code>android:configChanges</code> attribute is generally not good practice.</p>

<h3>Deprecated: Override <code>onRetainNonConfigurationInstance()</code></h3>

<p>Prior to Honeycomb&#39;s release, the recommended means of transferring
active objects across Activity instances was to override the
<code>onRetainNonConfigurationInstance()</code> and <code>getLastNonConfigurationInstance()</code>
methods. Using this approach, transferring an active object
across Activity instances was merely a matter of returning the
active object in <code>onRetainNonConfigurationInstance()</code> and retrieving
it in <code>getLastNonConfigurationInstance()</code>. As of API 13, these methods
have been deprecated in favor of the more Fragment&#39;s <code>setRetainInstance(boolean)</code>
capability, which provides a much cleaner and modular means of
retaining objects during configuration changes. We discuss this
Fragment-based approach in the next section.</p>

<h3>Recommended: Manage the Object Inside a Retained <code>Fragment</code></h3>

<p>Ever since the introduction of Fragments in Android 3.0, the recommended
means of retaining active objects across Activity instances is to wrap
and manage them inside of a retained &quot;worker&quot; Fragment. By default,
Fragments are destroyed and recreated along with their parent Activitys
when a configuration change occurs. Calling <code>Fragment#setRetainInstance(true)</code>
allows us to bypass this destroy-and-recreate cycle, signaling the system to
retain the current instance of the fragment when the activity is recreated.
As we will see, this will prove to be extremely useful with Fragments that
hold objects like running <code>Thread</code>s, <code>AsyncTask</code>s, <code>Socket</code>s, etc.</p>

<p>The sample code below serves as a basic example of how to retain an
<code>AsyncTask</code> across a configuration change using retained Fragments.
The code guarantees that progress updates and results are delivered
back to the currently displayed Activity instance and ensures that
we never accidentally leak an <code>AsyncTask</code> during a configuration change.
The design consists of two classes, a <code>MainActivity</code>...</p>

<div class="scrollable">

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="java"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * This Activity displays the screen&#39;s UI, creates a TaskFragment</span>
<span class="cm"> * to manage the task, and receives progress updates and results </span>
<span class="cm"> * from the TaskFragment when they occur.</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="kd">implements</span> <span class="n">TaskFragment</span><span class="o">.</span><span class="na">TaskCallbacks</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="n">TaskFragment</span> <span class="n">mTaskFragment</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">main</span><span class="o">);</span>

    <span class="n">FragmentManager</span> <span class="n">fm</span> <span class="o">=</span> <span class="n">getFragmentManager</span><span class="o">();</span>
    <span class="n">mTaskFragment</span> <span class="o">=</span> <span class="o">(</span><span class="n">TaskFragment</span><span class="o">)</span> <span class="n">fm</span><span class="o">.</span><span class="na">findFragmentByTag</span><span class="o">(</span><span class="s">&quot;task&quot;</span><span class="o">);</span>

    <span class="c1">// If the Fragment is non-null, then it is currently being</span>
    <span class="c1">// retained across a configuration change.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mTaskFragment</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">mTaskFragment</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TaskFragment</span><span class="o">();</span>
      <span class="n">fm</span><span class="o">.</span><span class="na">beginTransaction</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">mTaskFragment</span><span class="o">,</span> <span class="s">&quot;task&quot;</span><span class="o">).</span><span class="na">commit</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// TODO: initialize views, restore saved state, etc.</span>
  <span class="o">}</span>

  <span class="c1">// The four methods below are called by the TaskFragment when new</span>
  <span class="c1">// progress updates or results are available. The MainActivity </span>
  <span class="c1">// should respond by updating its UI to indicate the change.</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onPreExecute</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onProgressUpdate</span><span class="o">(</span><span class="kt">int</span> <span class="n">percent</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCancelled</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onPostExecute</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

</div>

<p>...and a <code>TaskFragment</code>...</p>

<div class="scrollable">

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="java">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * This Fragment manages a single background task and retains </span>
<span class="cm"> * itself across configuration changes.</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TaskFragment</span> <span class="kd">extends</span> <span class="n">Fragment</span> <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * Callback interface through which the fragment will report the</span>
<span class="cm">   * task&#39;s progress and results back to the Activity.</span>
<span class="cm">   */</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">interface</span> <span class="nc">TaskCallbacks</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">onPreExecute</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">onProgressUpdate</span><span class="o">(</span><span class="kt">int</span> <span class="n">percent</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">onCancelled</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">onPostExecute</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="n">TaskCallbacks</span> <span class="n">mCallbacks</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">DummyTask</span> <span class="n">mTask</span><span class="o">;</span>

  <span class="cm">/**</span>
<span class="cm">   * Hold a reference to the parent Activity so we can report the</span>
<span class="cm">   * task&#39;s current progress and results. The Android framework </span>
<span class="cm">   * will pass us a reference to the newly created Activity after </span>
<span class="cm">   * each configuration change.</span>
<span class="cm">   */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAttach</span><span class="o">(</span><span class="n">Activity</span> <span class="n">activity</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onAttach</span><span class="o">(</span><span class="n">activity</span><span class="o">);</span>
    <span class="n">mCallbacks</span> <span class="o">=</span> <span class="o">(</span><span class="n">TaskCallbacks</span><span class="o">)</span> <span class="n">activity</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * This method will only be called once when the retained</span>
<span class="cm">   * Fragment is first created.</span>
<span class="cm">   */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>

    <span class="c1">// Retain this fragment across configuration changes.</span>
    <span class="n">setRetainInstance</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

    <span class="c1">// Create and execute the background task.</span>
    <span class="n">mTask</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DummyTask</span><span class="o">();</span>
    <span class="n">mTask</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Set the callback to null so we don&#39;t accidentally leak the </span>
<span class="cm">   * Activity instance.</span>
<span class="cm">   */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDetach</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onDetach</span><span class="o">();</span>
    <span class="n">mCallbacks</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * A dummy task that performs some (dumb) background work and</span>
<span class="cm">   * proxies progress updates and results back to the Activity.</span>
<span class="cm">   *</span>
<span class="cm">   * Note that we need to check if the callbacks are null in each</span>
<span class="cm">   * method in case they are invoked after the Activity&#39;s and</span>
<span class="cm">   * Fragment&#39;s onDestroy() method have been called.</span>
<span class="cm">   */</span>
  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">DummyTask</span> <span class="kd">extends</span> <span class="n">AsyncTask</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Void</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPreExecute</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">mCallbacks</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mCallbacks</span><span class="o">.</span><span class="na">onPreExecute</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Note that we do NOT call the callback object&#39;s methods</span>
<span class="cm">     * directly from the background thread, as this could result </span>
<span class="cm">     * in a race condition.</span>
<span class="cm">     */</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="n">Void</span> <span class="nf">doInBackground</span><span class="o">(</span><span class="n">Void</span><span class="o">...</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">!</span><span class="n">isCancelled</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">SystemClock</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="n">publishProgress</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onProgressUpdate</span><span class="o">(</span><span class="n">Integer</span><span class="o">...</span> <span class="n">percent</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">mCallbacks</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mCallbacks</span><span class="o">.</span><span class="na">onProgressUpdate</span><span class="o">(</span><span class="n">percent</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCancelled</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">mCallbacks</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mCallbacks</span><span class="o">.</span><span class="na">onCancelled</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPostExecute</span><span class="o">(</span><span class="n">Void</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">mCallbacks</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mCallbacks</span><span class="o">.</span><span class="na">onPostExecute</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

</div>

<h3>Flow of Events</h3>

<p>When the <code>MainActivity</code> starts up for the first time, it instantiates and adds
the <code>TaskFragment</code> to the Activity&#39;s state. The <code>TaskFragment</code> creates and
executes an <code>AsyncTask</code> and proxies progress updates and results back to the
<code>MainActivity</code> via the <code>TaskCallbacks</code> interface. When a configuration change
occurs, the <code>MainActivity</code> goes through its normal lifecycle events, and once
created the new Activity instance is passed to the <code>onAttach(Activity)</code> method,
thus ensuring that the <code>TaskFragment</code> will always hold a reference to the
currently displayed Activity instance even after the configuration change.
The resulting design is both simple and reliable; the application framework
will handle re-assigning Activity instances as they are torn down and recreated,
and the <code>TaskFragment</code> and its <code>AsyncTask</code> never need to worry about the
unpredictable occurrence of a configuration change. Note also that it is impossible
for <code>onPostExecute()</code> to be executed in between the calls to <code>onDetach()</code> and
<code>onAttach()</code>, as explained in <a href="http://stackoverflow.com/q/19964180/844882">this StackOverflow answer</a>
and in my reply to Doug Stevenson in
<a href="https://plus.google.com/u/0/+AlexLockwood/posts/etWuiiRiqLf">this Google+ post</a>
(there is also some discussion about this in the comments below).</p>

<h3>Conclusion</h3>

<p>Synchronizing background tasks with the Activity lifecycle can be tricky and
configuration changes will only add to the confusion. Fortunately, retained
Fragments make handling these events very easy by consistently maintaining a
reference to its parent Activity, even after being destroyed and recreated.</p>

<p>A sample application illustrating how to correctly use retained Fragments to
achieve this effect is available for download on the
<a href="https://play.google.com/store/apps/details?id=com.adp.retaintask">Play Store</a>.
The source code is available on <a href="https://github.com/alexjlockwood/worker-fragments">GitHub</a>.
Download it, import it into Eclipse, and modify it all you want!</p>

<p><a href="/assets/images/posts/2013/04/29/worker-fragments-screenshot.png">
<img src="/assets/images/posts/2013/04/29/worker-fragments-screenshot.png" style="max-width:400px;height=225px;" />
</a></p>

<p>As always, leave a comment if you have any questions and don&#39;t forget to +1 this
blog in the top right corner!</p>

    </div>
    
    <div id="post-last-updated">Last updated January 14, 2014.</div>
    
    <div class="post-pagination">
      
      <div class="prev"><a rel="prev" href="/2013/04/activitys-threads-memory-leaks.html">Older &#187;</a></div>
      
      
      <div class="next"><a rel="next" href="/2013/07/binders-window-tokens.html">&#171; Newer</a></div>
      
    </div>

    <div id="responsive-post-bottom-ad">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-3588752900040136"
           data-ad-slot="6089694851"
           data-ad-format="auto"></ins>
      <script>
	(adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
    
    <div class="post-comments">
      <div id="disqus_thread"></div>
      <script src="/scripts/disqus-lazy-load.js"></script>
    </div>
    
  </div>

  
  <div class="side suggested">
    <h4>Related Posts</h4>
    <ul class="related">
    <li><a href="/2013/08/fragment-transaction-commit-state-loss.html">Fragment Transactions &amp; Activity State Loss</a></li>
    <li><a href="/2013/01/inner-class-handler-memory-leak.html">How to Leak a Context: Handlers &amp; Inner Classes</a></li>
    <li><a href="/2013/04/activitys-threads-memory-leaks.html">Activitys, Threads, &amp; Memory Leaks</a></li>
    </ul>
  </div>
  
</div>

<!-- Tweet button javascript -->
<script>!function(e,a,f){var c,b=e.getElementsByTagName(a)[0];if(!e.getElementById(f)){c=e.createElement(a);c.id=f;c.src="https://platform.twitter.com/widgets.js";b.parentNode.insertBefore(c,b)}}(document,"script","twitter-wjs");</script>

<!-- Like button javascript -->
<div id="fb-root"></div><script>(function(e,a,f){var c,b=e.getElementsByTagName(a)[0];if(e.getElementById(f)){return}c=e.createElement(a);c.id=f;c.src="//connect.facebook.net/en_US/all.js#xfbml=1";b.parentNode.insertBefore(c,b)}(document,"script","facebook-jssdk"));</script>

	</div>
      </div>

      <div id="info" class="cf">
	<div class="right">
          <div class="box">
            <h3>About this Blog</h3>
            <p>Android Design Patterns is a website for developers who wish to better understand the Android application framework. The tutorials here emphasize proper code design and project maintainability.</p>
            <div class="g-plusone" data-annotation="inline" data-width="300" data-href=""></div>
          </div>
          <div class="box">
            <h3>Find a typo?</h3>
            <p>Submit a pull request! The code powering this site is open-source and available on <a href="https://github.com/alexjlockwood/alexjlockwood.github.io">GitHub</a>. Corrections are appreciated and encouraged! Click <a href="https://github.com/alexjlockwood/alexjlockwood.github.io/blob/master/README.md#find-a-typo">here</a> for instructions.</p>
          </div>
	</div>
	<div class="box gbadge">
          <div class="g-person" data-href="//plus.google.com/+AlexLockwood" data-rel="author"></div>
	</div>
      </div>
    </div>

    <div id="responsive-home-page-bottom-ad" class="container">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-3588752900040136"
           data-ad-slot="3555030858"
           data-ad-format="auto"></ins>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>

    <div id="copyright" class="container">
      <p>&copy; 2012-2014 Android Design Patterns</p>
    </div>

    <script type="text/javascript">
      (function(){var a=document.createElement("script");
      a.type="text/javascript";a.async=true;a.src="https://apis.google.com/js/platform.js";
      var b=document.getElementsByTagName("script")[0];
      b.parentNode.insertBefore(a,b)})();
    </script>

  </body>
</html>
