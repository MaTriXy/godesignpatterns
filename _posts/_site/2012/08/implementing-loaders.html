<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="google-site-verification" content="VqGny1x9EAeoXjY8v2hWFZGBUZFNQnavIOXVkY50mdk" />
    <meta name="msvalidate.01" content="AFECEF07C08280E3BFA946DDCE26B76C" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@alexjlockwood" />
    <meta name="twitter:creator" content="@alexjlockwood" />
    <meta name="twitter:domain" content="" />
    
    <!-- Don't include normal description meta tag for now. Only include twitter:description since it is explicitly required. -->
    <meta name="twitter:description" content="Android Design Patterns is a website for developers who wish to better understand the Android application framework. The tutorials here emphasize proper code design and project maintainability." />
    
    <meta property="og:locale" content="en_US" />
    <meta property="og:title" content="Implementing Loaders (part 3)" />
    
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2012-08-21T00:00:00-04:00" />
    <meta property="article:modified_time" content="2014-01-16T00:00:00-05:00" />
    
    <meta property="og:url" content="/2012/08/implementing-loaders.html" />
    <meta property="og:site_name" content="Android Design Patterns" />
    
    <meta property="og:image" content="/assets/images/favicon.jpg" />
    <title>Implementing Loaders (part 3) | Android Design Patterns</title>
    <link rel="canonical" href="/2012/08/implementing-loaders.html" />
    <link rel="icon" href="/assets/images/favicon.jpg" type="image/x-icon">
    <link href="/feed.atom" rel="alternate" title="Android Design Patterns - Feed" type="application/atom+xml" />
    <link rel="stylesheet" type="text/css" href="/css/all.css" />

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
  </head>

  <body>
    <div id="header">
      <div class="container">
        <h3 id="blog-header"><a href="/">Android Design Patterns</a></h3>
        <nav class="pull-right">
          <a href="/archives/">Archives</a>
          <a href="/about/">About</a>
        </nav>
      </div>
    </div>

    <div id="social" class="container">
      <a href="https://plus.google.com/100751609891157863386?rel=author" class="googleplus"><i class="icon-gplus"></i></a>
      <a href="https://twitter.com/alexjlockwood" class="twitter"><i class="icon-twitter"></i></a>
      <a href="https://github.com/alexjlockwood" class="github"><i class="icon-github-circled"></i></a>
      <a href="/feed.atom" class="rss"><i class="icon-rss"></i></a>
    </div>

    <div class="main container">
      <div id="content">
	<div class="blog-index">
          <div itemscope itemtype="http://schema.org/BlogPosting" class="post">
  <header><h1 itemprop="name">Implementing Loaders (part 3)</h1></header>

  <div class="side">
    <div class="date-posted" >
      Posted <span itemprop="datePublished" content="2012-08-21T00:00:00-04:00" class="date">Aug 21, 2012</span>
      <div class="author">by <a href="https://google.com/+AlexLockwood"><span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Alex Lockwood</span></span></a></div>
    </div>

    <div class="share-buttons">
      <div class="g-plusone" data-size="medium"></div>
      <div class="tweet"><a href="https://twitter.com/share" class="twitter-share-button" data-via="alexjlockwood" data-lang="en">Tweet</a></div>
      <div class="fb-like" data-href="/2012/08/implementing-loaders.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
    </div>
  </div>

  <div class="body">
    <div itemprop="articleBody">
      <p>This post introduces the <code>Loader&lt;D&gt;</code> class as well as custom Loader implementations.
This is the third of a series of posts I will be writing on Loaders and the LoaderManager:</p>

<ul>
<li><strong>Part 1:</strong> <a href="/2012/07/loaders-and-loadermanager-background.html">Life Before Loaders</a></li>
<li><strong>Part 2:</strong> <a href="/2012/07/understanding-loadermanager.html">Understanding the LoaderManager</a></li>
<li><strong>Part 3:</strong> <a href="/2012/08/implementing-loaders.html">Implementing Loaders</a></li>
<li><strong>Part 4:</strong> <a href="/2012/09/tutorial-loader-loadermanager.html">Tutorial: AppListLoader</a></li>
</ul>

<p>First things first, if you haven’t read my previous two posts, I suggest you do so before continuing further.
Here is a very brief summary of what this blog has covered so far.
<a href="/2012/07/loaders-and-loadermanager-background.html">Life Before Loaders (part 1)</a> described the
flaws of the pre-Honeycomb 3.0 API and its tendency to perform lengthy queries on the main UI thread.
These UI-unfriendly APIs resulted in unresponsive applications and were the primary motivation for introducing
the Loader and the LoaderManager in Android 3.0.
<a href="/2012/07/understanding-loadermanager.html">Understanding the LoaderManager (part 2)</a> introduced
the LoaderManager class and its role in delivering asynchronously loaded data to the client. The LoaderManager
manages its Loaders across the Activity/Fragment lifecycle and can retain loaded data across configuration changes.</p>

<!--more-->

<h3>Loader Basics</h3>

<p>Loaders are responsible for performing queries on a separate thread, monitoring the data source for changes,
and delivering new results to a registered listener (usually the LoaderManager) when changes are detected.
These characteristics make Loaders a powerful addition to the Android SDK for several reasons:</p>

<ol>
<li><p><b>They encapsulate the actual loading of data.</b> The Activity/Fragment no longer needs to know how to load data.
 Instead, the Activity/Fragment delegates the task to the Loader, which carries out the request behind the scenes
 and has its results delivered back to the Activity/Fragment.</p></li>
<li><p><b>They abstract out the idea of threads from the client.</b> The Activity/Fragment does not need to worry
 about offloading queries to a separate thread, as the Loader will do this automatically. This reduces
 code complexity and eliminates potential thread-related bugs.</p></li>
<li><p><b>They are entirely <i>event-driven</i>.</b> Loaders monitor the underlying data source and automatically
 perform new loads for up-to-date results when changes are detected. This makes working with Loaders
 easy, as the client can simply trust that the Loader will auto-update its data on its own.
 All the Activity/Fragment has to do is initialize the Loader and respond to any results that might
 be delivered. Everything in between is done by the Loader.</p></li>
</ol>

<p>Loaders are a somewhat advanced topic and may take some time getting used to. We begin by analyzing
its four defining characteristics in the next section.</p>

<h3>What Makes Up a Loader?</h3>

<p>There are four characteristics which ultimately determine a Loader’s behavior:</p>

<ol>
<li><p><b>A task to perform the asynchronous load.</b> To ensure that loads are done on a separate thread,
 subclasses should extend <code>AsyncTaskLoader&lt;D&gt;</code> as opposed to the <code>Loader&lt;D&gt;</code> class.
 <code>AsyncTaskLoader&lt;D&gt;</code> is an abstract Loader which provides an <code>AsyncTask</code> to do its work.
 When subclassed, implementing the asynchronous task is as simple as implementing the abstract
 <code>loadInBackground()</code> method, which is called on a worker thread to perform the data load.</p></li>
<li><p><b>A registered listener to receive the Loader&#39;s results when it completes a load.</b><sup><a href="#footnote1" id="ref1">1</a></sup>
 For each of its Loaders, the LoaderManager registers an <code>OnLoadCompleteListener&lt;D&gt;</code> which will forward
 the Loader’s delivered results to the client with a call to <code>onLoadFinished(Loader&lt;D&gt; loader, D result)</code>.
 Loaders should deliver results to these registered listeners with a call to <code>Loader#deliverResult(D result)</code>.</p></li>
<li><p><b>One of three<sup><a href="#footnote2" id="ref2">2</a></sup> distinct states.</b> Any given Loader will either be in a
 <em>started</em>, <em>stopped</em>, or <em>reset</em> state:</p>

<ul>
<li>Loaders in a <em>started state</em> execute loads and may deliver their results to the listener at any
time. Started Loaders should monitor for changes and perform new loads when changes are detected.
Once started, the Loader will remain in a started state until it is either stopped or reset.
This is the only state in which <code>onLoadFinished</code> will ever be called.</li>
<li>Loaders in a <em>stopped state</em> continue to monitor for changes but should <strong>not</strong>
deliver results to the client. From a stopped state, the Loader may either be started or reset.</li>
<li>Loaders in a <em>reset state</em> should <strong>not</strong> execute new loads, should <strong>not</strong> deliver new
results, and should <strong>not</strong> monitor for changes. When a loader enters a reset state, it should
invalidate and free any data associated with it for garbage collection (likewise, the client should
make sure they remove any references to this data, since it will no longer be available). More
often than not, reset Loaders will never be called again; however, in some cases they may be started,
so they should be able to start running properly again if necessary.</li>
</ul></li>
<li><p><strong>An observer to receive notifications when the data source has changed.</strong> Loaders should implement an observer of some sort
 (i.e. a <code>ContentObserver</code>, a <code>BroadcastReceiver</code>, etc.) to monitor the underlying data source for changes.
 When a change is detected, the observer should call <code>Loader#onContentChanged()</code>, which will either (a) force a new
 load if the Loader is in a started state or, (b) raise a flag indicating that a change has been made so that if the Loader
 is ever started again, it will know that it should reload its data.</p></li>
</ol>

<p>By now you should have a basic understanding of how Loaders work. If not, I suggest you let it sink in for a bit and
come back later to read through once more (reading the
<a href="http://developer.android.com/reference/android/content/Loader.html">documentation</a> never hurts either!).
That being said, let’s get our hands dirty with the actual code!</p>

<h3>Implementing the Loader</h3>

<p>As I stated earlier, there is a lot that you must keep in mind when implementing your own custom Loaders.
Subclasses must implement <code>loadInBackground()</code> and should override <code>onStartLoading()</code>,
<code>onStopLoading()</code>, <code>onReset()</code>, <code>onCanceled()</code>, and
<code>deliverResult(D results)</code> to achieve a fully functioning Loader. Overriding these methods is
very important as the LoaderManager will call them regularly depending on the state of the Activity/Fragment
lifecycle. For example, when an Activity is first started, the Activity instructs the LoaderManager to
start each of its Loaders in <code>Activity#onStart()</code>. If a Loader is not already started, the
LoaderManager calls <code>startLoading()</code>, which puts the Loader in a started state and immediately
calls the Loader’s <code>onStartLoading()</code> method. In other words, a lot of work that the LoaderManager
does behind the scenes <strong>relies on the Loader being correctly implemented</strong>, so don’t take the task of
implementing these methods lightly!</p>

<p>The code below serves as a template of what a Loader implementation typically looks like. The <code>SampleLoader</code>
queries a list of <code>SampleItem</code> objects and delivers a <code>List&lt;SampleItem&gt;</code> to the client:</p>

<div class="scrollable">

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="java">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SampleLoader</span> <span class="kd">extends</span> <span class="n">AsyncTaskLoader</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">SampleItem</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="c1">// We hold a reference to the Loader’s data here.</span>
  <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">SampleItem</span><span class="o">&gt;</span> <span class="n">mData</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">SampleLoader</span><span class="o">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Loaders may be used across multiple Activitys (assuming they aren&#39;t</span>
    <span class="c1">// bound to the LoaderManager), so NEVER hold a reference to the context</span>
    <span class="c1">// directly. Doing so will cause you to leak an entire Activity&#39;s context.</span>
    <span class="c1">// The superclass constructor will store a reference to the Application</span>
    <span class="c1">// Context instead, and can be retrieved with a call to getContext().</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="cm">/****************************************************/</span>
  <span class="cm">/** (1) A task that performs the asynchronous load **/</span>
  <span class="cm">/****************************************************/</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">SampleItem</span><span class="o">&gt;</span> <span class="nf">loadInBackground</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// This method is called on a background thread and should generate a</span>
    <span class="c1">// new set of data to be delivered back to the client.</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">SampleItem</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">SampleItem</span><span class="o">&gt;();</span>

    <span class="c1">// TODO: Perform the query here and add the results to &#39;data&#39;.</span>

    <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/********************************************************/</span>
  <span class="cm">/** (2) Deliver the results to the registered listener **/</span>
  <span class="cm">/********************************************************/</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deliverResult</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">SampleItem</span><span class="o">&gt;</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isReset</span><span class="o">())</span> <span class="o">{</span>
      <span class="c1">// The Loader has been reset; ignore the result and invalidate the data.</span>
      <span class="n">releaseResources</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Hold a reference to the old data so it doesn&#39;t get garbage collected.</span>
    <span class="c1">// We must protect it until the new data has been delivered.</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">SampleItem</span><span class="o">&gt;</span> <span class="n">oldData</span> <span class="o">=</span> <span class="n">mData</span><span class="o">;</span>
    <span class="n">mData</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">isStarted</span><span class="o">())</span> <span class="o">{</span>
      <span class="c1">// If the Loader is in a started state, deliver the results to the</span>
      <span class="c1">// client. The superclass method does this for us.</span>
      <span class="kd">super</span><span class="o">.</span><span class="na">deliverResult</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Invalidate the old data as we don&#39;t need it any more.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">oldData</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">oldData</span> <span class="o">!=</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">releaseResources</span><span class="o">(</span><span class="n">oldData</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="cm">/*********************************************************/</span>
  <span class="cm">/** (3) Implement the Loader’s state-dependent behavior **/</span>
  <span class="cm">/*********************************************************/</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onStartLoading</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mData</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// Deliver any previously loaded data immediately.</span>
      <span class="n">deliverResult</span><span class="o">(</span><span class="n">mData</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Begin monitoring the underlying data source.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mObserver</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">mObserver</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SampleObserver</span><span class="o">();</span>
      <span class="c1">// TODO: register the observer</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">takeContentChanged</span><span class="o">()</span> <span class="o">||</span> <span class="n">mData</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// When the observer detects a change, it should call onContentChanged()</span>
      <span class="c1">// on the Loader, which will cause the next call to takeContentChanged()</span>
      <span class="c1">// to return true. If this is ever the case (or if the current data is</span>
      <span class="c1">// null), we force a new load.</span>
      <span class="n">forceLoad</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onStopLoading</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// The Loader is in a stopped state, so we should attempt to cancel the </span>
    <span class="c1">// current load (if there is one).</span>
    <span class="n">cancelLoad</span><span class="o">();</span>

    <span class="c1">// Note that we leave the observer as is. Loaders in a stopped state</span>
    <span class="c1">// should still monitor the data source for changes so that the Loader</span>
    <span class="c1">// will know to force a new load if it is ever started again.</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onReset</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Ensure the loader has been stopped.</span>
    <span class="n">onStopLoading</span><span class="o">();</span>

    <span class="c1">// At this point we can release the resources associated with &#39;mData&#39;.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mData</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">releaseResources</span><span class="o">(</span><span class="n">mData</span><span class="o">);</span>
      <span class="n">mData</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// The Loader is being reset, so we should stop monitoring for changes.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mObserver</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// TODO: unregister the observer</span>
      <span class="n">mObserver</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCanceled</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">SampleItem</span><span class="o">&gt;</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Attempt to cancel the current asynchronous load.</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCanceled</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>

    <span class="c1">// The load has been canceled, so we should release the resources</span>
    <span class="c1">// associated with &#39;data&#39;.</span>
    <span class="n">releaseResources</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">releaseResources</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">SampleItem</span><span class="o">&gt;</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// For a simple List, there is nothing to do. For something like a Cursor, we </span>
    <span class="c1">// would close it in this method. All resources associated with the Loader</span>
    <span class="c1">// should be released here.</span>
  <span class="o">}</span>

  <span class="cm">/*********************************************************************/</span>
  <span class="cm">/** (4) Observer which receives notifications when the data changes **/</span>
  <span class="cm">/*********************************************************************/</span>
 
  <span class="c1">// NOTE: Implementing an observer is outside the scope of this post (this example</span>
  <span class="c1">// uses a made-up &quot;SampleObserver&quot; to illustrate when/where the observer should </span>
  <span class="c1">// be initialized). </span>
  
  <span class="c1">// The observer could be anything so long as it is able to detect content changes</span>
  <span class="c1">// and report them to the loader with a call to onContentChanged(). For example,</span>
  <span class="c1">// if you were writing a Loader which loads a list of all installed applications</span>
  <span class="c1">// on the device, the observer could be a BroadcastReceiver that listens for the</span>
  <span class="c1">// ACTION_PACKAGE_ADDED intent, and calls onContentChanged() on the particular </span>
  <span class="c1">// Loader whenever the receiver detects that a new application has been installed.</span>
  <span class="c1">// Please don’t hesitate to leave a comment if you still find this confusing! :)</span>
  <span class="kd">private</span> <span class="n">SampleObserver</span> <span class="n">mObserver</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

</div>

<h3>Conclusion</h3>

<p>I hope these posts were useful and gave you a better understanding of how Loaders and the LoaderManager work
together to perform asynchronous, auto-updating queries. Remember that Loaders are your friends... if you use
them, your app will benefit in both responsiveness and the amount of code you need to write to get everything
working properly! Hopefully I could help lessen the learning curve a bit by detailing them out!</p>

<p>As always, please don’t hesitate to leave a comment if you have any questions! And don&#39;t
forget to +1 this blog in the top right corner if you found it helpful!</p>

<hr class="footnote-divider" />

<p><sup id="footnote1">1</sup> You don&#39;t need to worry about registering a listener for your Loader unless you plan on using it without the LoaderManager. The LoaderManager will act as this &quot;listener&quot; and will forward any results that the Loader delivers to the <code>LoaderCallbacks#onLoadFinished</code> method. <a href="#ref1" title="Jump to footnote 1.">&#8617;</a></p>

<p><sup id="footnote2">2</sup> Loaders may also be in an <a href="http://developer.android.com/reference/android/content/Loader.html#onAbandon()">&quot;abandoned&quot;</a> state. This is an optional intermediary state between &quot;stopped&quot; and &quot;reset&quot; and is not discussed here for the sake of brevity. That said, in my experience implementing <code>onAbandon()</code> is usually not necessary. <a href="#ref2" title="Jump to footnote 2.">&#8617;</a></p>

    </div>
    
    <div id="post-last-updated">Last updated January 16, 2014.</div>
    
    <div class="post-pagination">
      
      <div class="prev"><a rel="prev" href="/2012/08/exit-application-dialogs-are-evil-dont.html">Older &#187;</a></div>
      
      
      <div class="next"><a rel="next" href="/2012/08/follow-this-blog-on-google-currents_8022.html">&#171; Newer</a></div>
      
    </div>

    <div id="responsive-post-bottom-ad">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-3588752900040136"
           data-ad-slot="6089694851"
           data-ad-format="auto"></ins>
      <script>
	(adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
    
    <div class="post-comments">
      <div id="disqus_thread"></div>
      <script src="/scripts/disqus-lazy-load.js"></script>
    </div>
    
  </div>

  
  <div class="side suggested">
    <h4>Related Posts</h4>
    <ul class="related">
    <li><a href="/2013/04/retaining-objects-across-config-changes.html">Handling Configuration Changes with Fragments</a></li>
    <li><a href="/2014/01/thread-scheduling-in-android.html">Thread Scheduling in Android</a></li>
    <li><a href="/2013/07/binders-window-tokens.html">Binders &amp; Window Tokens</a></li>
    </ul>
  </div>
  
</div>

<!-- Tweet button javascript -->
<script>!function(e,a,f){var c,b=e.getElementsByTagName(a)[0];if(!e.getElementById(f)){c=e.createElement(a);c.id=f;c.src="https://platform.twitter.com/widgets.js";b.parentNode.insertBefore(c,b)}}(document,"script","twitter-wjs");</script>

<!-- Like button javascript -->
<div id="fb-root"></div><script>(function(e,a,f){var c,b=e.getElementsByTagName(a)[0];if(e.getElementById(f)){return}c=e.createElement(a);c.id=f;c.src="//connect.facebook.net/en_US/all.js#xfbml=1";b.parentNode.insertBefore(c,b)}(document,"script","facebook-jssdk"));</script>

	</div>
      </div>

      <div id="info" class="cf">
	<div class="right">
          <div class="box">
            <h3>About this Blog</h3>
            <p>Android Design Patterns is a website for developers who wish to better understand the Android application framework. The tutorials here emphasize proper code design and project maintainability.</p>
            <div class="g-plusone" data-annotation="inline" data-width="300" data-href=""></div>
          </div>
          <div class="box">
            <h3>Find a typo?</h3>
            <p>Submit a pull request! The code powering this site is open-source and available on <a href="https://github.com/alexjlockwood/alexjlockwood.github.io">GitHub</a>. Corrections are appreciated and encouraged! Click <a href="https://github.com/alexjlockwood/alexjlockwood.github.io/blob/master/README.md#find-a-typo">here</a> for instructions.</p>
          </div>
	</div>
	<div class="box gbadge">
          <div class="g-person" data-href="//plus.google.com/+AlexLockwood" data-rel="author"></div>
	</div>
      </div>
    </div>

    <div id="responsive-home-page-bottom-ad" class="container">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-3588752900040136"
           data-ad-slot="3555030858"
           data-ad-format="auto"></ins>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>

    <div id="copyright" class="container">
      <p>&copy; 2012-2014 Android Design Patterns</p>
    </div>

    <script type="text/javascript">
      (function(){var a=document.createElement("script");
      a.type="text/javascript";a.async=true;a.src="https://apis.google.com/js/platform.js";
      var b=document.getElementsByTagName("script")[0];
      b.parentNode.insertBefore(a,b)})();
    </script>

  </body>
</html>
