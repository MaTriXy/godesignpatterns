<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="google-site-verification" content="VqGny1x9EAeoXjY8v2hWFZGBUZFNQnavIOXVkY50mdk" />
    <meta name="msvalidate.01" content="AFECEF07C08280E3BFA946DDCE26B76C" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@alexjlockwood" />
    <meta name="twitter:creator" content="@alexjlockwood" />
    <meta name="twitter:domain" content="" />
    
    <!-- Don't include normal description meta tag for now. Only include twitter:description since it is explicitly required. -->
    <meta name="twitter:description" content="Android Design Patterns is a website for developers who wish to better understand the Android application framework. The tutorials here emphasize proper code design and project maintainability." />
    
    <meta property="og:locale" content="en_US" />
    <meta property="og:title" content="Activitys, Threads, &amp; Memory Leaks" />
    
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2013-04-15T00:00:00-04:00" />
    <meta property="article:modified_time" content="2014-01-14T00:00:00-05:00" />
    
    <meta property="og:url" content="/2013/04/activitys-threads-memory-leaks.html" />
    <meta property="og:site_name" content="Android Design Patterns" />
    
    <meta property="og:image" content="/assets/images/favicon256.png" />
    <title>Activitys, Threads, &amp; Memory Leaks | Android Design Patterns</title>
    <link rel="canonical" href="/2013/04/activitys-threads-memory-leaks.html" />
    <link rel="icon" href="/assets/images/favicon128.png" type="image/x-icon">
    <link href="/feed.atom" rel="alternate" title="Android Design Patterns - Feed" type="application/atom+xml" />
    <link rel="stylesheet" type="text/css" href="/css/all.css" />

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
  </head>

  <body>
    <div id="header">
      <div class="container">
        <h3 id="blog-header"><a href="/">Android Design Patterns</a></h3>
        <nav class="pull-right">
          <a href="/archives/">Archives</a>
          <a href="/about/">About</a>
        </nav>
      </div>
    </div>

    <div id="social" class="container">
      <a href="https://plus.google.com/100751609891157863386?rel=author" class="googleplus"><i class="icon-gplus"></i></a>
      <a href="https://twitter.com/alexjlockwood" class="twitter"><i class="icon-twitter"></i></a>
      <a href="https://github.com/alexjlockwood" class="github"><i class="icon-github-circled"></i></a>
      <a href="/feed.atom" class="rss"><i class="icon-rss"></i></a>
    </div>

    <div class="main container">
      <div id="content">
	<div class="blog-index">
          <div itemscope itemtype="http://schema.org/BlogPosting" class="post">
  <header><h1 itemprop="name">Activitys, Threads, &amp; Memory Leaks</h1></header>

  <div class="side">
    <div class="date-posted" >
      Posted <span itemprop="datePublished" content="2013-04-15T00:00:00-04:00" class="date">Apr 15, 2013</span>
      <div class="author">by <a href="https://google.com/+AlexLockwood"><span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Alex Lockwood</span></span></a></div>
    </div>

    <div class="share-buttons">
      <div class="g-plusone" data-size="medium"></div>
      <div class="tweet"><a href="https://twitter.com/share" class="twitter-share-button" data-via="alexjlockwood" data-lang="en">Tweet</a></div>
      <div class="fb-like" data-href="/2013/04/activitys-threads-memory-leaks.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
    </div>
  </div>

  <div class="body">
    <div itemprop="articleBody">
      <blockquote>
<p>Note: the source code in this blog post is available on
<a href="https://github.com/alexjlockwood/leaky-threads">GitHub</a>.</p>
</blockquote>

<p>A common difficulty in Android programming is coordinating long-running tasks
over the Activity lifecycle and avoiding the subtle memory leaks which might
result. Consider the Activity code below, which starts and loops a new thread
upon its creation:</p>

<div class="scrollable">

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="java"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Example illustrating how threads persist across configuration</span>
<span class="cm"> * changes (which cause the underlying Activity instance to be</span>
<span class="cm"> * destroyed). The Activity context also leaks because the thread</span>
<span class="cm"> * is instantiated as an anonymous class, which holds an implicit</span>
<span class="cm"> * reference to the outer Activity instance, therefore preventing</span>
<span class="cm"> * it from being garbage collected.</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="n">exampleOne</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">exampleOne</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nf">Thread</span><span class="o">()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">SystemClock</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

</div>

<!--more-->

<p>When a configuration change occurs, causing the entire Activity to be
destroyed and re-created, it is easy to assume that Android will clean
up after us and reclaim the memory associated with the Activity and its
running thread. However, this is not the case. Both will leak never to be
reclaimed, and the result will likely be a significant reduction in performance.</p>

<h3>How to Leak an Activity</h3>

<p>The first memory leak should be immediately obvious if you read my
<a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html">previous post</a>
on Handlers and inner classes. In Java, non-static anonymous classes hold an implicit
reference to their enclosing class. If you&#39;re not careful, storing this reference
can result in the Activity being retained when it would otherwise be eligible for
garbage collection. Activity objects hold a reference to their entire view hierarchy
and all its resources, so if you leak one, you leak a lot of memory.</p>

<p>The problem is only exacerbated by configuration changes, which signal the destruction
and re-creation of the entire underlying Activity. For example, after ten orientation
changes running the code above, we can see
(using <a href="http://www.eclipse.org/mat/">Eclipse Memory Analyzer</a>) that each
Activity object is in fact retained in memory as a result of these implicit references:</p>

<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: center; margin-left: 0em; text-align: left;">
  <tbody>
    <tr><td style="text-align: center;"><a class="no-border" href="/assets/images/posts/2013/04/15/activity-leak.png"><img border="0" height="175" src="/assets/images/posts/2013/04/15/activity-leak.png" width="400" /></a>
    </td></tr>
    <tr><td class="tr-caption" style="text-align: center;">Figure 1. Activity instances retained in memory after ten orientation changes.
    </td></tr>
  </tbody>
</table>

<p>After each configuration change, the Android system creates a new Activity and leaves
the old one behind to be garbage collected. However, the thread holds an implicit
reference to the old Activity and prevents it from ever being reclaimed. As a result,
each new Activity is leaked and all resources associated with them are never able to be
reclaimed.</p>

<p>The fix is easy once we&#39;ve identified the source of the problem: declare the
thread as a private static inner class as shown below.</p>

<div class="scrollable">

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="java"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * This example avoids leaking an Activity context by declaring the </span>
<span class="cm"> * thread as a private static inner class, but the threads still </span>
<span class="cm"> * continue to run even across configuration changes. The DVM has a</span>
<span class="cm"> * reference to all running threads and whether or not these threads</span>
<span class="cm"> * are garbage collected has nothing to do with the Activity lifecycle.</span>
<span class="cm"> * Active threads will continue to run until the kernel destroys your </span>
<span class="cm"> * application&#39;s process.</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="n">exampleTwo</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">exampleTwo</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nf">MyThread</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SystemClock</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

</div>

<p>The new thread no longer holds an implicit reference to the Activity, and the
Activity will be eligible for garbage collection after the configuration change.</p>

<h3>How to Leak a Thread</h3>

<p>The second issue is that for each new Activity that is created, a thread is
leaked and never able to be reclaimed. Threads in Java are GC roots; that is,
the Dalvik Virtual Machine (DVM) keeps hard references to all active threads
in the runtime system, and as a result, threads that are left running will
never be eligible for garbage collection. For this reason, you must remember
to implement cancellation policies for your background threads! One example
of how this might be done is shown below:</p>

<div class="scrollable">

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="java"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Same as example two, except for this time we have implemented a</span>
<span class="cm"> * cancellation policy for our thread, ensuring that it is never </span>
<span class="cm"> * leaked! onDestroy() is usually a good place to close your active </span>
<span class="cm"> * threads before exiting the Activity.</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">MyThread</span> <span class="n">mThread</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="n">exampleThree</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">exampleThree</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">mThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyThread</span><span class="o">();</span>
    <span class="n">mThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Static inner classes don&#39;t hold implicit references to their</span>
<span class="cm">   * enclosing class, so the Activity instance won&#39;t be leaked across</span>
<span class="cm">   * configuration changes.</span>
<span class="cm">   */</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">mRunning</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">mRunning</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">mRunning</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SystemClock</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">mRunning</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onDestroy</span><span class="o">();</span>
    <span class="n">mThread</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

</div>

<p>In the code above, closing the thread in <code>onDestroy()</code> ensures that
you never accidentally leak the thread. If you want to persist the same thread
across configuration changes (as opposed to closing and re-creating a new thread
each time), consider using a retained, UI-less worker fragment to perform the
long-running task. Check out my blog post, titled
<a href="http://www.androiddesignpatterns.com/2013/04/retaining-objects-across-config-changes.html">Handling Configuration Changes with Fragments</a>,
for an example explaining how this can be done. There is also a comprehensive
example available in the
<a href="https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/app/FragmentRetainInstance.java">API demos</a>
which illustrates the concept.</p>

<h3>Conclusion</h3>

<p>In Android, coordinating long-running tasks over the Activity lifecycle can be
difficult and memory leaks can result if you aren&#39;t careful. Here are some
general tips to consider when dealing with coordinating your long-running
background tasks with the Activity lifecycle:</p>

<ul>
<li><p><strong>Favor static inner classes over nonstatic.</strong> Each instance of a nonstatic inner
class will have an extraneous reference to its outer Activity instance. Storing
this reference can result in the Activity being retained when it would otherwise
be eligible for garbage collection. If your static inner class requires a
reference to the underlying Activity in order to function properly, make sure
you wrap the object in a <code>WeakReference</code> to ensure that you don&#39;t
accidentally leak the Activity.</p></li>
<li><p><strong>Don&#39;t assume that Java will ever clean up your running threads for you.</strong> In the
example above, it is easy to assume that when the user exits the Activity and the
Activity instance is finalized for garbage collection, any running threads associated
with that Activity will be reclaimed as well. <em>This is never the case.</em> Java
threads will persist until either they are explicitly closed or the entire process
is killed by the Android system. As a result, it is extremely important that you
remember to implement cancellation policies for your background threads, and to
take appropriate action when Activity lifecycle events occur.</p></li>
<li><p><strong>Consider whether or not you should use a Thread.</strong> The Android application framework
provides many classes designed to make background threading easier for developers.
For example, consider using a Loader instead of a thread for performing short-lived
asynchronous background queries in conjunction with the Activity lifecycle. Likewise,
if the background thread is not tied to any specific Activity, consider using a
Service and report the results back to the UI using a <code>BroadcastReceiver</code>.
Lastly, remember that everything discussed regarding threads in this blog post also
applies to <code>AsyncTask</code>s (since the <code>AsyncTask</code> class uses an
<code>ExecutorService</code> to execute its tasks). However, given that <code>AsyncTask</code>s
should only be used for short-lived operations (&quot;a few seconds at most&quot;, as per the
<a href="http://developer.android.com/reference/android/os/AsyncTask.html">documentation</a>),
leaking an Activity or a thread by these means should never be an issue.</p></li>
</ul>

<p>The source code for this blog post is available on
<a href="https://github.com/alexjlockwood/leaky-threads">GitHub</a>. A standalone
application (which mirrors the source code exactly) is also available for download on
<a href="https://play.google.com/store/apps/details?id=com.adp.leaky.threads">Google Play</a>.</p>

<p><a class="no-border" href="https://play.google.com/store/apps/details?id=com.adp.leaky.threads">
<img width="320px" height="180px" border="0" src="/assets/images/posts/2013/04/15/leaky-threads-screenshot.png" />
</a></p>

<p>As always, leave a comment if you have any questions and don&#39;t forget to +1
this blog in the top right corner!</p>

    </div>
    
    <div id="post-last-updated">Last updated January 14, 2014.</div>
    
    <div class="post-pagination">
      
      <div class="prev"><a rel="prev" href="/2013/01/inner-class-handler-memory-leak.html">Older &#187;</a></div>
      
      
      <div class="next"><a rel="next" href="/2013/04/retaining-objects-across-config-changes.html">&#171; Newer</a></div>
      
    </div>

    <div id="responsive-post-bottom-ad">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-3588752900040136"
           data-ad-slot="6089694851"
           data-ad-format="auto"></ins>
      <script>
	(adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
    
    <div class="post-comments">
      <div id="disqus_thread"></div>
      <script src="/scripts/disqus-lazy-load.js"></script>
    </div>
    
  </div>

  
  <div class="side suggested">
    <h4>Related Posts</h4>
    <ul class="related">
    <li><a href="/2014/01/thread-scheduling-in-android.html">Thread Scheduling in Android</a></li>
    <li><a href="/2013/08/fragment-transaction-commit-state-loss.html">Fragment Transactions &amp; Activity State Loss</a></li>
    <li><a href="/2013/04/retaining-objects-across-config-changes.html">Handling Configuration Changes with Fragments</a></li>
    </ul>
  </div>
  
</div>

	</div>
      </div>

      <div id="info" class="cf">
	<div class="right">
          <div class="box">
            <h3>+1 this blog!</h3>
            <p>Android Design Patterns is a website for developers who wish to better understand the Android application framework. The tutorials here emphasize proper code design and project maintainability.</p>
            <div style="text-align:center">
              <div class="g-plusone" data-href=""></div>
	      <div class="tweet"><a href="https://twitter.com/share" class="twitter-share-button" data-via="alexjlockwood" data-lang="en">Tweet</a></div>
	      <div class="fb-like" data-href="/2013/04/activitys-threads-memory-leaks.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
            </div>
          </div>
          <div class="box">
            <h3>Find a typo?</h3>
            <p>Submit a pull request! The code powering this site is open-source and available on <a href="https://github.com/alexjlockwood/alexjlockwood.github.io">GitHub</a>. Corrections are appreciated and encouraged! Click <a href="https://github.com/alexjlockwood/alexjlockwood.github.io/blob/master/README.md#find-a-typo">here</a> for instructions.</p>
          </div>
	</div>
	<div class="box gbadge">
          <div class="g-person" data-href="//plus.google.com/+AlexLockwood" data-rel="author"></div>
	</div>
      </div>
    </div>

    <div id="responsive-home-page-bottom-ad" class="container">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-3588752900040136"
           data-ad-slot="3555030858"
           data-ad-format="auto"></ins>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>

    <div id="copyright" class="container">
      <p>&copy; 2012-2014 Android Design Patterns</p>
    </div>

    <!-- +1 button javascript -->
    <script type="text/javascript">
      (function(){var a=document.createElement("script");
      a.type="text/javascript";a.async=true;a.src="https://apis.google.com/js/platform.js";
      var b=document.getElementsByTagName("script")[0];
      b.parentNode.insertBefore(a,b)})();
    </script>

    <!-- Tweet button javascript -->
    <script>!function(e,a,f){var c,b=e.getElementsByTagName(a)[0];if(!e.getElementById(f)){c=e.createElement(a);c.id=f;c.src="https://platform.twitter.com/widgets.js";b.parentNode.insertBefore(c,b)}}(document,"script","twitter-wjs");</script>

    <!-- Like button javascript -->
    <div id="fb-root"></div><script>(function(e,a,f){var c,b=e.getElementsByTagName(a)[0];if(e.getElementById(f)){return}c=e.createElement(a);c.id=f;c.src="//connect.facebook.net/en_US/all.js#xfbml=1";b.parentNode.insertBefore(c,b)}(document,"script","facebook-jssdk"));</script>

  </body>
</html>
