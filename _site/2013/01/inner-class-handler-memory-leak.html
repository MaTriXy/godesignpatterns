<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="google-site-verification" content="VqGny1x9EAeoXjY8v2hWFZGBUZFNQnavIOXVkY50mdk" />
    <meta name="msvalidate.01" content="AFECEF07C08280E3BFA946DDCE26B76C" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@alexjlockwood" />
    <meta name="twitter:creator" content="@alexjlockwood" />
    <meta name="twitter:domain" content="" />
    
    <!-- Don't include normal description meta tag for now. Only include twitter:description since it is explicitly required. -->
    <meta name="twitter:description" content="Android Design Patterns is a website for developers who wish to better understand the Android application framework. The tutorials here emphasize proper code design and project maintainability." />
    
    <meta property="og:locale" content="en_US" />
    <meta property="og:title" content="How to Leak a Context: Handlers &amp; Inner Classes" />
    
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2013-01-14T00:00:00-05:00" />
    <meta property="article:modified_time" content="2014-01-05T00:00:00-05:00" />
    
    <meta property="og:url" content="/2013/01/inner-class-handler-memory-leak.html" />
    <meta property="og:site_name" content="Android Design Patterns" />
    
    <meta property="og:image" content="/assets/images/favicon256.png" />
    <title>How to Leak a Context: Handlers &amp; Inner Classes | Android Design Patterns</title>
    <link rel="canonical" href="/2013/01/inner-class-handler-memory-leak.html" />
    <link rel="icon" href="/assets/images/favicon128.png" type="image/x-icon">
    <link href="/feed.atom" rel="alternate" title="Android Design Patterns - Feed" type="application/atom+xml" />
    <link rel="stylesheet" type="text/css" href="/css/all.css" />

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
  </head>

  <body>
    <div id="header">
      <div class="container">
        <h3 id="blog-header"><a href="/">Android Design Patterns</a></h3>
        <nav class="pull-right">
          <a href="/archives/">Archives</a>
          <a href="/about/">About</a>
        </nav>
      </div>
    </div>

    <div id="social" class="container">
      <a href="https://plus.google.com/100751609891157863386?rel=author" class="googleplus"><i class="icon-gplus"></i></a>
      <a href="https://twitter.com/alexjlockwood" class="twitter"><i class="icon-twitter"></i></a>
      <a href="https://github.com/alexjlockwood" class="github"><i class="icon-github-circled"></i></a>
      <a href="/feed.atom" class="rss"><i class="icon-rss"></i></a>
    </div>

    <div class="main container">
      <div id="content">
	<div class="blog-index">
          <div itemscope itemtype="http://schema.org/BlogPosting" class="post">
  <header><h1 itemprop="name">How to Leak a Context: Handlers &amp; Inner Classes</h1></header>

  <div class="side">
    <div class="date-posted" >
      Posted <span itemprop="datePublished" content="2013-01-14T00:00:00-05:00" class="date">Jan 14, 2013</span>
      <div class="author">by <a href="https://google.com/+AlexLockwood"><span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Alex Lockwood</span></span></a></div>
    </div>

    <div class="share-buttons">
      <div class="g-plusone" data-size="medium"></div>
      <div class="tweet"><a href="https://twitter.com/share" class="twitter-share-button" data-via="alexjlockwood" data-lang="en">Tweet</a></div>
      <div class="fb-like" data-href="/2013/01/inner-class-handler-memory-leak.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
    </div>
  </div>

  <div class="body">
    <div itemprop="articleBody">
      <p>Consider the following code:</p>

<div class="scrollable">

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="java">1
2
3
4
5
6
7
8
9</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SampleActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Handler</span> <span class="n">mLeakyHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// ... </span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

</div>

<p>While not readily obvious, this code can cause cause a massive memory leak.
Android Lint will give the following warning: </p>

<blockquote>
<p>In Android, Handler classes should be static or leaks might occur.</p>
</blockquote>

<p>But where exactly is the leak and how might it happen? Let&#39;s determine the
source of the problem by first documenting what we know:</p>

<!--more-->

<ol>
<li><p>When an Android application first starts, the framework creates a 
 <a href="http://developer.android.com/reference/android/os/Looper.html"><code>Looper</code></a>
 object for the application&#39;s main thread. A <code>Looper</code> implements a simple message queue,
 processing <a href="http://developer.android.com/reference/android/os/Message.html"><code>Message</code></a>
 objects in a loop one after another. All major application framework events (such
 as Activity lifecycle method calls, button clicks, etc.) are contained inside
 <code>Message</code> objects, which are added to the <code>Looper</code>&#39;s message queue and are processed
 one-by-one. The main thread&#39;s <code>Looper</code> exists throughout the application&#39;s lifecycle.</p></li>
<li><p>When a <a href="http://developer.android.com/reference/android/os/Handler.html"><code>Handler</code></a>
 is instantiated on the main thread, it is associated with the <code>Looper</code>&#39;s message queue.
 Messages posted to the message queue will hold a reference to the <code>Handler</code> so that the
 framework can call
 <a href="http://developer.android.com/reference/android/os/Handler.html#handleMessage(android.os.Message)"><code>Handler#handleMessage(Message)</code></a>
 when the <code>Looper</code> eventually processes the message.</p></li>
<li><p>In Java, non-static inner and anonymous classes hold an implicit reference to their
 outer class. Static inner classes, on the other hand, do not.</p></li>
</ol>

<p>So where exactly is the memory leak? It&#39;s very subtle, but consider the following code as an example:</p>

<div class="scrollable">

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="java"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SampleActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
 
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Handler</span> <span class="n">mLeakyHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// ...</span>
    <span class="o">}</span>
  <span class="o">}</span>
 
  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
 
    <span class="c1">// Post a message and delay its execution for 10 minutes.</span>
    <span class="n">mLeakyHandler</span><span class="o">.</span><span class="na">postDelayed</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>
    <span class="o">},</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">);</span>
 
    <span class="c1">// Go back to the previous Activity.</span>
    <span class="n">finish</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

</div>

<p>When the activity is finished, the delayed message will continue to live in the main thread&#39;s
message queue for 10 minutes before it is processed. The message holds a reference to the
activity&#39;s <code>Handler</code>, and the <code>Handler</code> holds an implicit reference to its outer class (the
<code>SampleActivity</code>, in this case). This reference will persist until the message is processed,
thus preventing the activity context from being garbage collected and leaking all of the
application&#39;s resources. Note that the same is true with the anonymous Runnable class on
line 15. Non-static instances of anonymous classes hold an implicit reference to their outer
class, so the context will be leaked.</p>

<p>To fix the problem, subclass the <code>Handler</code> in a new file or use a static inner class instead.
Static inner classes do not hold an implicit reference to their outer class, so the activity
will not be leaked. If you need to invoke the outer activity&#39;s methods from within the
<code>Handler</code>, have the Handler hold a <code>WeakReference</code> to the activity so you don&#39;t accidentally
leak a context. To fix the memory leak that occurs when we instantiate the anonymous Runnable
class, we make the variable a static field of the class (since static instances of anonymous
classes do not hold an implicit reference to their outer class):</p>

<div class="scrollable">

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="java"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SampleActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * Instances of static inner classes do not hold an implicit</span>
<span class="cm">   * reference to their outer class.</span>
<span class="cm">   */</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyHandler</span> <span class="kd">extends</span> <span class="n">Handler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">SampleActivity</span><span class="o">&gt;</span> <span class="n">mActivity</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyHandler</span><span class="o">(</span><span class="n">SampleActivity</span> <span class="n">activity</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">mActivity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">SampleActivity</span><span class="o">&gt;(</span><span class="n">activity</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">SampleActivity</span> <span class="n">activity</span> <span class="o">=</span> <span class="n">mActivity</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">activity</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ...</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">MyHandler</span> <span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyHandler</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>

  <span class="cm">/**</span>
<span class="cm">   * Instances of anonymous classes do not hold an implicit</span>
<span class="cm">   * reference to their outer class when they are &quot;static&quot;.</span>
<span class="cm">   */</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Runnable</span> <span class="n">sRunnable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>
  <span class="o">};</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>

    <span class="c1">// Post a message and delay its execution for 10 minutes.</span>
    <span class="n">mHandler</span><span class="o">.</span><span class="na">postDelayed</span><span class="o">(</span><span class="n">sRunnable</span><span class="o">,</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">);</span>
    
    <span class="c1">// Go back to the previous Activity.</span>
    <span class="n">finish</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

</div>

<p>The difference between static and non-static inner classes is subtle, but is something
every Android developer should understand. What&#39;s the bottom line? Avoid using non-static
inner classes in an activity if instances of the inner class outlive the activity&#39;s
lifecycle. Instead, prefer static inner classes and hold a weak reference to the activity inside.</p>

<p>As always, leave a comment if you have any questions and don&#39;t forget to +1 this blog in
the top right corner! :)</p>

    </div>
    
    <div id="post-last-updated">Last updated January 5, 2014.</div>
    
    <div class="post-pagination">
      
      <div class="prev"><a rel="prev" href="/2013/01/gcm-appengine-golang-android-backends.html">Older &#187;</a></div>
      
      
      <div class="next"><a rel="next" href="/2013/04/activitys-threads-memory-leaks.html">&#171; Newer</a></div>
      
    </div>

    <div id="responsive-post-bottom-ad">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-3588752900040136"
           data-ad-slot="6089694851"
           data-ad-format="auto"></ins>
      <script>
	(adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
    
    <div class="post-comments">
      <div id="disqus_thread"></div>
      <script src="/scripts/disqus-lazy-load.js"></script>
    </div>
    
  </div>

  
  <div class="side suggested">
    <h4>Related Posts</h4>
    <ul class="related">
    <li><a href="/2012/07/understanding-loadermanager.html">Understanding the LoaderManager (part 2)</a></li>
    <li><a href="/2013/04/activitys-threads-memory-leaks.html">Activitys, Threads, &amp; Memory Leaks</a></li>
    <li><a href="/2013/04/retaining-objects-across-config-changes.html">Handling Configuration Changes with Fragments</a></li>
    </ul>
  </div>
  
</div>

	</div>
      </div>

      <div id="info" class="cf">
	<div class="right">
          <div class="box">
            <h3>+1 this blog!</h3>
            <p>Android Design Patterns is a website for developers who wish to better understand the Android application framework. The tutorials here emphasize proper code design and project maintainability.</p>
            <div style="text-align:center">
              <div class="g-plusone" data-href=""></div>
	      <div class="tweet"><a href="https://twitter.com/share" class="twitter-share-button" data-via="alexjlockwood" data-lang="en">Tweet</a></div>
	      <div class="fb-like" data-href="/2013/01/inner-class-handler-memory-leak.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
            </div>
          </div>
          <div class="box">
            <h3>Find a typo?</h3>
            <p>Submit a pull request! The code powering this site is open-source and available on <a href="https://github.com/alexjlockwood/alexjlockwood.github.io">GitHub</a>. Corrections are appreciated and encouraged! Click <a href="https://github.com/alexjlockwood/alexjlockwood.github.io/blob/master/README.md#find-a-typo">here</a> for instructions.</p>
          </div>
	</div>
	<div class="box gbadge">
          <div class="g-person" data-href="//plus.google.com/+AlexLockwood" data-rel="author"></div>
	</div>
      </div>
    </div>

    <div id="responsive-home-page-bottom-ad" class="container">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-3588752900040136"
           data-ad-slot="3555030858"
           data-ad-format="auto"></ins>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>

    <div id="copyright" class="container">
      <p>&copy; 2012-2014 Android Design Patterns</p>
    </div>

    <!-- +1 button javascript -->
    <script type="text/javascript">
      (function(){var a=document.createElement("script");
      a.type="text/javascript";a.async=true;a.src="https://apis.google.com/js/platform.js";
      var b=document.getElementsByTagName("script")[0];
      b.parentNode.insertBefore(a,b)})();
    </script>

    <!-- Tweet button javascript -->
    <script>!function(e,a,f){var c,b=e.getElementsByTagName(a)[0];if(!e.getElementById(f)){c=e.createElement(a);c.id=f;c.src="https://platform.twitter.com/widgets.js";b.parentNode.insertBefore(c,b)}}(document,"script","twitter-wjs");</script>

    <!-- Like button javascript -->
    <div id="fb-root"></div><script>(function(e,a,f){var c,b=e.getElementsByTagName(a)[0];if(e.getElementById(f)){return}c=e.createElement(a);c.id=f;c.src="//connect.facebook.net/en_US/all.js#xfbml=1";b.parentNode.insertBefore(c,b)}(document,"script","facebook-jssdk"));</script>

  </body>
</html>
